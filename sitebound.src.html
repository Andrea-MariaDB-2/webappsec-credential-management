<h1>Site-Bound Credentials</h1>
<pre class="metadata">
Status: ED
ED: https://w3c.github.io/webappsec-credential-management/sitebound.html
Shortname: credential-sitebound
Level: 1
Editor: Mike West 56384, Google Inc., mkwst@google.com
Group: webappsec
Abstract:
  This specification extends the Credential Management API, defining credential types that support
  authentication via username/password pairs, and federations.
Indent: 2
Version History: https://github.com/w3c/webappsec-credential-management/commits/master/sitebound.src.html
Boilerplate: omit conformance, omit feedback-header
!Participate: <a href="https://github.com/w3c/webappsec-credential-management/issues/new">File an issue</a> (<a href="https://github.com/w3c/webappsec-credential-management/issues">open issues</a>)
Markup Shorthands: css off, markdown on
</pre>
<pre class="link-defaults">
spec:html; type:dfn; for:/; text:origin
spec:webappsec-credential-management-1; type:dfn; text:credentials
spec:webappsec-credential-management-1; type:attribute; text:credentials
spec:fetch; type:dfn; for:/; text:request

<!-- These need to be exported -->
spec:webappsec-credential-management-1; type:dfn; text:credential chooser
spec:html; type:dfn; text:submittable element
spec:html; type:dfn; text:form owner
spec:html; type:dfn; text:autofill detail tokens
spec:url; type:dfn; text:urlencoded byte serializer
</pre>
<pre class="anchors">
spec: HTML; urlPrefix: https://html.spec.whatwg.org/multipage/
  urlPrefix: forms.html
    type: element-attr
      text: autocomplete; for: input; url: #attr-fe-autocomplete
      text: name; for: input; url: #attr-fe-name
      text: enctype; for: form; url: #concept-fs-enctype
    type: attr-value
      for: autocomplete
        text: current-password; url: attr-fe-autocomplete-current-password
        text: new-password; url: attr-fe-autocomplete-new-password
        text: nickname; url: attr-fe-autocomplete-nickname
        text: name; url: attr-fe-autocomplete-name
        text: photo; url: attr-fe-autocomplete-photo
        text: username; url: attr-fe-autocomplete-username
spec: XHR; urlPrefix: https://xhr.spec.whatwg.org/
  type: dfn
    text: entry; url: concept-formdata-entry
    text: entries; for: FormData; url: concept-formdata-entry
    text: name; for: entry; url: concept-formdata-entry-name
    text: value; for: entry; url: concept-formdata-entry-value
    text: type; for: entry; url: concept-formdata-entry-type
  type: interface
    text: FormData; url: interface-formdata
spec: PSL; urlPrefix: https://publicsuffix.org/list/
  type: dfn
    text: registerable domain; url: #
    text: public suffix; url: #
spec: FETCH; urlPrefix: https://fetch.spec.whatwg.org/
  type: dfn
    text: http-network-or-cache fetch; url: http-network-or-cache-fetch 

urlPrefix: https://w3c.github.io/webappsec-credential-management/base.html
  type: dfn
    text: user mediation
  type: abstract-op
    text: Retrieve a list of credentials
    text: Store a credential
    text: Retrieve an origin's requires user mediation flag
</pre>
<pre class="biblio">
{
  "PSL": {
    "authors": [ "Mozilla Foundation" ],
    "href": "https://publicsuffix.org/",
    "title": "Public Suffix List"
  },
  "WEB-LOGIN": {
    "authors": [ "Jason Denizac", "Robin Berjon", "Anne van Kesteren" ],
    "href": "https://github.com/jden/web-login",
    "title": "web-login"
  }
}
</pre>
<!--
████ ██    ██ ████████ ████████   ███████
 ██  ███   ██    ██    ██     ██ ██     ██
 ██  ████  ██    ██    ██     ██ ██     ██
 ██  ██ ██ ██    ██    ████████  ██     ██
 ██  ██  ████    ██    ██   ██   ██     ██
 ██  ██   ███    ██    ██    ██  ██     ██
████ ██    ██    ██    ██     ██  ███████
-->
<section>
  # Introduction # {#intro}

  <em>This section is not normative.</em>

  Signing into websites is more difficult than it should be. The user agent is in a unique position
  to improve the experience in a number of ways, and most modern user agents have recognized this by
  providing some measure of credential management natively in the browser. Users can save usernames
  and passwords for websites, and those [=credentials=] are autofilled into sign-in forms with
  varying degrees of success.

  The <{input/autocomplete}> attribute offers a declarative mechanism by which websites can work
  with user agents to improve the latter's ability to detect and fill sign-in forms by marking
  specific fields as "`username`" or "`current-password`", and user agents implement a wide variety
  of detection heuristics to work with websites which haven't taken the time to provide this detail
  in markup.

  While this combination of heuristic and declarative detection works relatively well, the status
  quo leaves some large gaps where detection is problematic. Sites with uncommon sign-in mechanisms
  (submitting credentials via {{XMLHttpRequest}} [[XMLHTTPREQUEST]], for instance) are difficult to
  reliably detect, as is the increasingly common case in which users wish to authenticate themselves
  using a federated identity provider. Allowing websites to more directly interact with the user
  agent's credential manager would allow the credential manager to be more accurate on the one hand,
  and to assist users with federated sign-in on the other.

  To that end, this document defines an extension to the Credential Management API
  [[CREDENTIAL-MANAGEMENT-1]], creating {{PasswordCredential}} and {{FederatedCredential}}
  interfaces that give developers imperative access to the user agent's [=credential store=].

  Note: The API defined here is intentionally small and simple: it does not intend to provide
  authentication in and of itself, but is limited to providing an interface to the existing
  credential managers implemented by existing user agents. That functionality is valuable _right
  now_, without significant effort on the part of either vendors or authors. There's certainly quite
  a bit more which could be done, of course. See [[#future-work]] for some thoughts we've punted for
  now, but which could be explored in future iterations of this API.

  ## Examples ## {#examples}

  ### Password-based Sign-in ### {#examples-password-signin}

  A website that supports only username/password pairs can request credentials, and use them with
  existing sign-in endpoints:

  <div class="example">
    <pre>
      navigator.<a attribute>credentials</a>.<a idl lt="get()" for="CredentialsContainer">get</a>({ "<a for="CredentialRequestOptions" dict-member>password</a>": true }).then(
          function(credential) {
            if (!credential) {
              // The user either doesn't have credentials for this site, or
              // refused to share them. Insert some code here to fall back to
              // a basic login form (or, ideally, do nothing, since this API
              // should really be progressive enhancement on top of an
              // existing form).
              return;
            }
            if (credential.type == "<a const>password</a>") {
              fetch("https://example.com/loginEndpoint", { credentials: credential, method: "POST" })
                .then(function (response) {
                  if (/* |response| indicates a successful login */) {
                    // Store the credential again, see note below.
                    navigator.<a attribute>credentials</a>.<a idl lt="store()" for="CredentialsContainer">store</a>(credential);
                    // Notify the user that sign-in succeeded! Do amazing, signed-in things!
                  } else {
                    // Insert some code here to fall back to a basic login form.
                  }
                });
            } else {
              // See <a href="#examples-federated-signin">the Federated Sign-in example</a>
            }
          });
    </pre>

    Note: The [=credential chooser=] presented by the user agent could allow the user to choose
    credentials that aren't actually stored for the current origin. For instance, it might offer up
    redentials from `https://m.example.com` when signing into `https://www.example.com` (as
    described in [[#security-cross-origin-leakage]]), or it might allow a user to create a new
    credential on the fly. Developers can deal gracefully with this uncertainty by calling
    {{CredentialsContainer/store()}} every time credentials are successfully used, even right after
    credentials have been retrieved from {{CredentialsContainer/get()}}: if the credentials aren't
    yet stored for the origin, the user will be given the opportunity to do so. If they are stored,
    the user won't be prompted.
  </div>

  ## Federated Sign-in ## {#examples-federated-signin}

  A website that supports federated identity providers as well as passwords can request credentials,
  and use them to kick off the sign-in flow for the user's chosen provider:

  <div class="example">
    <pre>
      navigator.<a attribute>credentials</a>.<a idl lt="get()" for="CredentialsContainer">get</a>({
        "<a for="CredentialRequestOptions" dict-member>password</a>": true,
        "<a dict-member>federated</a>": {
          "<a idl>providers</a>": [ "https://www.facebook.com", "https://accounts.google.com" ]
        }
      }).then(
          function(credential) {
            if (!credential)
              return;

            if (credential.type == "<a const>federated</a>") {
              switch (credential.<a idl for="FederatedCredential">provider</a>) {
              case "https://www.facebook.com/":
                // Use Facebook's SDK, a la
                // <a href="https://developers.facebook.com/docs/facebook-login/login-flow-for-web/#logindialog">https://developers.facebook.com/docs/facebook-login/login-flow-for-web/#logindialog</a>
                FB.login(function (response) {
                  if (response.status === "authorized") {
                    // Can now use FB.api() calls
                  } else {
                    // Explain to the user that we would really like them to
                    // click "Log me in".
                  }
                });
                break;

              case "https://accounts.google.com/":
                // Ditto
                break;

              // ...
              }
            } else {
              fetch("https://example.com/loginEndpoint", { credentials: credential, method: "POST" })
                .then(function (response) { ... })
                .catch(function (response) { ... });
            }
          });
    </pre>

    Note: This API does not go out to the identity provider to grab a token, or authenticate the
    user in any way. It provides a hint to the website as to which identity provider the user
    prefers to use, and little more. See [[#future-work]] for directions future versions of this
    API could take.
  </div>

  ## Post-sign-in Confirmation ## {#examples-post-signin}

  To ensure that users are offered to store new credentials after a successful sign-in, they need
  to be passed to {{CredentialsContainer/store()}}.

  <div class="example">
    If a user is signed in by calling {{fetch()}} on a {{PasswordCredential}} object, submitting
    that data to a sign-in endpoint, then we can check the response to determine whether the user
    was signed in successfully, and notify the user agent accordingly. Given a sign-in form like the
    following:

    <pre>
      &lt;form action="https://example.com/login" method="POST" id="theForm"&gt;
        &lt;label for="username"&gt;Username&lt;/label&gt;
        &lt;input type="text" id="username" name="username" <a element-attr for="input">autocomplete</a>="<a attr-value>username</a>"&gt;
        &lt;label for="password"&gt;Password&lt;/label&gt;
        &lt;input type="password" id="password" name="password" <a element-attr for="input">autocomplete</a>="<a attr-value>current-password</a>"&gt;
        &lt;input type="submit"&gt;
      &lt;/form&gt;
    </pre>

    Then the developer can handle the form submission with something like the following handler:

    <pre>
      document.querySelector('#theForm').addEventListener("submit", e =&gt; {
          if (<a attribute lt="credentials">navigator.credentials</a>) {
            e.preventDefault();

            // Construct a new <a idl>PasswordCredential</a> from the <a idl>HTMLFormElement</a>
            // that fired the "submit" event: this will suck up the values of the fields
            // labeled with "username" and "current-password" <a element-attr for="input">autocomplete</a>
            // attributes:
            var c = new <a idl lt="PasswordCredential(form)">PasswordCredential</a>(e.target);

            // Fetch the form's action URL, passing that new credential object in
            // as the fetch's credentials. If the response indicates success, ask
            // the user agent to ask the user to store the credential for future use:
            var init = { method: "POST", credentials: c };
            fetch(e.target.action, init).then(r =&gt; {
              if (/* |r| is a "successful" <a idl>Response</a> */)
                <a idl lt="store()">navigator.credentials.store</a>(c);
            });
          }
      });
    </pre>
  </div>

  <div class="example">
    If we're using a <a>federated identity provider</a>:

    <pre>
      if (<a attribute lt="credentials">navigator.credentials</a>) {
        navigator.<a attribute>credentials</a>.<a idl lt="store()">store</a>(
          new <a idl>FederatedCredential</a>({
            "<a idl for="CredentialData">id</a>": "username",
            "<a idl for="FederatedCredentialData">provider</a>": "https://federation.com"
          })
        );
      }
    </pre>
  </div>

  ## Change Password ## {#examples-change-password}

  This same storage mechanism can be reused for "password change" with no modifications: if the
  user changes their credentials, the website can notify the user agent that they've successfully
  signed in with new credentials. The user agent can then update the credentials it stores:

  <div class="example">
    MegaCorp Inc. allows users to change their passwords by POSTing data to
    a backend server asynchronously. After doing so successfully, they can
    update the user's credentials by calling {{CredentialsContainer/store()}}
    with the new information.

    Given a password change form like the following:

    <pre>
      &lt;form action="https://example.com/changePassword" method="POST" id="theForm"&gt;
        &lt;input type="hidden" name="username" <a element-attr for="input">autocomplete</a>="<a attr-value>username</a>" value="user"&gt;
        &lt;label for="password"&gt;New Password&lt;/label&gt;
        &lt;input type="password" id="password" name="password" <a element-attr for="input">autocomplete</a>="<a attr-value>new-password</a>"&gt;
        &lt;input type="submit"&gt;
      &lt;/form&gt;
    </pre>

    The developer can handle the form submission with something like the following:

    <pre>
      document.querySelector('#theForm').addEventListener("submit", e =&gt; {
        if (<a attribute lt="credentials">navigator.credentials</a>) {
          e.preventDefault();

          // Construct a new <a idl>PasswordCredential</a> from the <a idl>HTMLFormElement</a>
          // that fired the "submit" event: this will suck up the values of the fields
          // labeled with "username" and "new-password" <a element-attr for="input">autocomplete</a>
          // attributes:
          var c = new <a idl lt="PasswordCredential(form)">PasswordCredential</a>(e.target);

          // Fetch the form's action URL, passing that new credential object in
          // as the fetch's credentials. If the response indicates success, ask
          // the user agent to ask the user to store the credential for future use:
          var init = { method: "POST", credentials: c };
          fetch(e.target.action, init).then(r =&gt; {
            if (/* |r| is a "successful" <a idl>Response</a> */)
              <a idl lt="store()">navigator.credentials.store</a>(c);
          });
        }
      });
    </pre>
  </div>

  ## Layering on top of a legacy system ## {#examples-legacy}

  The API is designed in such a way as to cleanly sit on top of an existing password-based sign-in
  system's backend. For instance, the username and password parameters can be renamed by adjusting
  the {{PasswordCredential}}'s {{PasswordCredential/idName}} and {{PasswordCredential/passwordName}}
  attributes, and additional data can be added to a request by setting the
  {{PasswordCredential/additionalData}} attribute.

  <div class="example">
    MegaCorp Inc. has an existing sign-in system that expects the username to be submitted as a
    parameter named "`u`" and a the password as a parameter named "`p`". The following code
    accomplishes this:

    <pre>
      // Given a <a idl>PasswordCredential</a> |credential|:
      credential.idName = "u";
      credential.passwordName = "p";
      fetch("https://example.com/loginEndpoint", { credentials: credential, method: "POST" });
    </pre>
  </div>

  <div class="example">
    Further, MegaCorp Inc. protects itself against attack by appending a CSRF token to the request.
    The following code accomplishes this:

    <pre>
      // Given a <a idl>PasswordCredential</a> |credential|:
      credential.<a idl>additionalData</a> = new FormData();
      credential.<a idl>additionalData</a>.append("csrf", "[random token value goes here]");
      
      fetch("https://example.com/loginEndpoint", { credentials: credential, method: "POST" });
    </pre>
  </div>

  <div class="example">
    MegaCorp Inc.'s backend servers cannot accept POST requests submitted as `multipart/form-data`.
    They need to submit the credential information as `application/x-www-form-urlencoded` instead.
    They can accomplish this by setting the {{PasswordCredential/additionalData}} attribute to a
    {{URLSearchParams}} object (which serializes as a urlencoded submission):

    <pre>
      // Given a <a idl>PasswordCredential</a> |credential|:
      credential.<a idl>additionalData</a> = new URLSearchParams();
      
      // Note that MegaCorp Inc. doesn't need to append any data to the
      // object. Setting `additionalData` to an empty `URLSearchParams` object
      // is enough to change the content type of the submission.
      
      fetch("https://example.com/loginEndpoint", { credentials: credential, method: "POST" });
    </pre>
  </div>
</section>

<section>
  # Framework # {#framework}

  This document extends the Credential Management API by adding two new types of [=credential=]
  objects, {{PasswordCredential}} and {{FederatedCredential}}, both inheriting from a
  {{SiteBoundCredential}} which contains some shared logic.

  ## The `SiteBoundCredential` Interface ## {#siteboundcredential-interface}

  The {{SiteBoundCredential}} inteface inherits from {{Credential}}, and serves as a base class for
  both {{PasswordCredential}} and {{FederatedCredential}}:

  <pre class="idl">
    [Exposed=Window, SecureContext]
    interface SiteBoundCredential : Credential {
      readonly attribute USVString name;
      readonly attribute USVString iconURL;
    };

    dictionary SiteBoundCredentialData : CredentialData {
      USVString name;
      USVString iconURL;
    };
  </pre>
  <dl dfn-for="SiteBoundCredential">
    :   <dfn attribute>name</dfn>
    ::  A human-readable name associated with a credential, suitable for display in a [=credential
        chooser=] to allow a user to disambiguate several [=credentials=] for an [=origin=].

    :   <dfn attribute>iconURL</dfn>
    ::  A URL, pointing to an image for the credential, also suitable for display in a [=credential
        chooser=]. The URL MUST be an <a><i lang="la">a priori</i> authenticated URL</a>.

        ISSUE(w3c/webappsec#247): Anne suggests that this might be better modeled as an
        `ImageBitmap` or `blob:`. We also need to figure out responsiveness. Perhaps
        [[APPMANIFEST]]'s format?

    :   <dfn attribute>\[[type]]</dfn>
    ::  The {{SiteBoundCredential}} [=interface object=] has an internal slot named `[[type]]` whose
        value is the empty string.

    :   <dfn attribute>\[[origin]]</dfn>
    ::  Each {{SiteBoundCredential}} object has an internal slot named `[[origin]]` whose value is
        [=origin=] for which the [=credential=] is valid. This property is not directly exposed to
        the web.
  </dl>

  {{SiteBoundCredential}}'s [=interface object=] defines two internal methods that override
  {{Credential}}'s implementation:

  <dfn for="SiteBoundCredential" method>\[[Retrieve]](options, mediation)</dfn> is defined in
  [[#request-credential]].

  <dfn for="SiteBoundCredential" method>\[[Store]](credential)</dfn> is defined in
  [[#store-credential]].

  ## The `PasswordCredential` Interface ## {#passwordcredential-interface}

  <pre class="idl">
    typedef (FormData or URLSearchParams) CredentialBodyType;

    [Constructor(PasswordCredentialData data),
     Constructor(HTMLFormElement form),
     Exposed=Window,
     SecureContext]
    interface PasswordCredential : SiteBoundCredential {
      attribute USVString idName;
      attribute USVString passwordName;

      attribute CredentialBodyType? additionalData;
    };

    [Exposed=Window, SecureContext]
    dictionary PasswordCredentialData : SiteBoundCredentialData {
      required USVString password;
    };
  </pre>
  <dl dfn-for="PasswordCredential">
    :   <dfn attribute>idName</dfn>
    ::  This attribute represents the name which will be used for the ID field when submitting the
        {{PasswordCredential}} to a remote endpoint via {{fetch()}}. It defaults to "`username`",
        but can be overridden by a developer to match whatever the backend service expects.

    :   <dfn attribute>passwordName</dfn>
    ::  This attribute represents the name which will be used for the ID field when submitting the
        {{PasswordCredential}} to a remote endpoint via {{fetch()}}. It defaults to "`password`",
        but can be overridden by a developer to match whatever the backend service expects.

    :   <dfn attribute>additionalData</dfn>
    ::  If the developer wishes to specify additional data to insert into the request body when
        submitting the credential information to a remote endpoint, they can do so by assigning a
        {{FormData}} or {{URLSearchParams}} object to this attribute. The credential information
        will be mixed into the object to produce the body. The value is `null` unless otherwise
        specified.

    :   <dfn attribute>\[[type]]</dfn>
    ::  The {{PasswordCredential}} [=interface object=] has an internal slot named `[[type]]` whose
        value is "`password`".

    :   <dfn attribute>\[[password]]</dfn>
    ::  Each {{PasswordCredential}} object has an internal slot named `[[password]]` which stores
        the credential's password. This property is not directly exposed to the web, but used to
        construct a request body during {{fetch()}}.

    :   <dfn constructor>PasswordCredential(form)</dfn>
    ::  This constructor is defined in [[#construct-passwordcredential-form]].

    :   <dfn constructor>PasswordCredential(data)</dfn>
    ::  This constructor is defined in [[#construct-passwordcredential-data]].
  </dl>

  {{PasswordCredential}}'s [=interface object=] contains two internal methods:
  <dfn for="PasswordCredential" method>\[[Retrieve]](options, mediation)</dfn> and
  <dfn for="PasswordCredential" method>\[[Store]](credential)</dfn>. Both are aliases to the
  {{SiteBoundCredential}} internal methods of the same name.

  ## The `FederatedCredential` Interface ## {#federatedcredential-interface}

  <pre class="idl">
    [Constructor(FederatedCredentialData data),
     Exposed=Window,
     SecureContext]
    interface FederatedCredential : SiteBoundCredential {
      readonly attribute USVString provider;
      readonly attribute DOMString? protocol;
    };

    [Exposed=Window, SecureContext]
    dictionary FederatedCredentialData : SiteBoundCredentialData {
      required USVString provider;
      DOMString protocol;
    };
  </pre>
  <dl dfn-for="FederatedCredential">
    :   <dfn attribute>provider</dfn>
    ::  This attribute represents the name which will be used for the ID field when submitting the
        {{PasswordCredential}} to a remote endpoint via {{fetch()}}. It defaults to "`username`",
        but can be overridden by a developer to match whatever the backend service expects.

    :   <dfn attribute>protocol</dfn>
    ::  This attribute represents the name which will be used for the ID field when submitting the
        {{PasswordCredential}} to a remote endpoint via {{fetch()}}. It defaults to "`password`",
        but can be overridden by a developer to match whatever the backend service expects.

    :   <dfn attribute>\[[type]]</dfn>
    ::  The {{FederatedCredential}} [=interface object=] has an internal slot named `[[type]]` whose
        value is "`federated`".

    :   <dfn constructor>FederatedCredential(data)</dfn>
    ::  This constructor is defined in [[#construct-passwordcredential-data]].
  </dl>

  {{FederatedCredential}}'s [=interface object=] contains two internal methods:
  <dfn for="FederatedCredential" method>\[[Retrieve]](options, mediation)</dfn> and
  <dfn for="FederatedCredential" method>\[[Store]](credential)</dfn>. Both are aliases to the
  {{SiteBoundCredential}} internal methods of the same name.

  ### Identifying Providers ### {#provider-identification}

  Every site should use the same identifier when referring to a specific federated identity
  provider. For example,
  <a href="https://developers.facebook.com/docs/facebook-login/v2.0">Facebook Login</a>
  shouldn't be referred to as "Facebook" and "Facebook Login" and "FB" and "FBL" and "Facebook.com"
  and so on. It should have a canonical identifier which everyone can make use of, as consistent
  identification makes it possible for user agents to be helpful.

  For consistency, federations passed into the APIs defined in this document (e.g.
  {{FederatedCredentialRequestOptions}}'s {{FederatedCredentialRequestOptions/providers}} array, or
  {{FederatedCredential}}'s {{FederatedCredential/provider}} property) MUST be identified by the
  <a lt="ASCII serialization of an origin">ASCII serialization</a> of the origin the provider uses
  for sign in. That is, Facebook would be represented by `https://www.facebook.com` and Google by
  `https://accounts.google.com`.

  This serialization of an [=origin=] does _not_ include a trailing U+002F SOLIDUS ("`/`"), but
  user agents SHOULD accept them silently: `https://accounts.google.com/` is clearly
  intended to be the same as `https://accounts.google.com`.

  ## `CredentialRequestOptions` Extension ## {#credentialrequestoptions-extension}

  Each credential type also extends {{CredentialRequestOptions}} to support
  {{CredentialsContainer/get()}}:

  <pre class="idl">
    dictionary FederatedCredentialRequestOptions {
      sequence&lt;USVString&gt; providers;
      sequence&lt;DOMString&gt; protocols;
    };

    [Exposed=Window, SecureContext]
    partial dictionary CredentialRequestOptions {
      boolean password = false;
      FederatedCredentialRequestOptions? federated;
    };
  </pre>
</section>

<!-- Big Text: Fetch -->
<section>
  # Integration with Fetch # {#fetch-integration}
  
  In order to actually authenticate a user, {{PasswordCredential}} objects may
  be submitted to a server for evaluation. To prevent the risk that sensitive
  credential information will be exposed directly to a page's JavaScript (see
  [[#security-cross-origin-leakage]]), we hide the credential information in
  non-web-exposed slots on the {{PasswordCredential}} object, and extract them
  during {{fetch()}} in ways that will remain opaque to anything other than the
  remote (same-origin) server.

  {{PasswordCredential}} objects may be bound to a {{Request}} by passing them
  into the {{Request}} constructor as the "`credentials`" member of a
  {{RequestInit}} object:
 
  <pre class="example">
    [ Given a `PasswordCredential` named 'c' ]
    var init = {
      method: "POST",
      credentials: c
    };
    var r = new Request("https://example.com/endpoint", init);
  </pre>

  Note: The credential information will be transmitted as the request's body,
  just as it would be for a form submission. This means that the "`method`"
  cannot be "`GET`".

  Until the request hits the network, the credential object will be hidden from
  JavaScript. Once the user agent determines that the {{Request}} is going to
  hit the network (that is, once Fetch hits the
  "<a>HTTP-network-or-cache fetch</a>" algorithm), the {{PasswordCredential}}
  will be serialized into a body and content type as defined in
  [[#body-extraction]], and the request will proceed out to the server-side
  authentication endpoint.

  ## Monkey Patches to Fetch ## {#monkey-patching}

  To accomplish the above, Fetch could be modified in the following ways:

  1.  A <a>request</a> has an associated <dfn for="request">attached
      credential</dfn> (null, or a {{PasswordCredential}}). Unless stated
      otherwise, it is null.

  2.  A <a>request</a>'s <a for="request">credentials mode</a> gains a new
      "`password`" value, which implies the same behavior as "`include`", with
      the additional assertion that the <a>request</a> has a non-null
      <a for="request">attached credential</a> which will be serialized into
      its <a for="request">body</a> when it hits the network.
      
  3.  The {{RequestCredentials}} enum is renamed to "`RequestCredentialsMode`,
      and likewise updated with the new "`password`" value:

      <pre class="idl">
        enum RequestCredentialsMode { "omit", "same-origin", "include", "password" };
      </pre>

  4.  The {{RequestInit}} dictionary is updated to accept a
      {{PasswordCredential}} as its `credentials` member:

      <pre class="idl">
        typedef (<a>PasswordCredential</a> or RequestCredentials) CredentialInfo;

        partial dictionary RequestInit {
          CredentialInfo credentials;
        };
      </pre>

  5.  Replace step 20 of the current {{Request}} constructor with the following:

      20. If |credentials| is non-null:

          1.  If |credentials| is a {{PasswordCredential}}, then set |request|'s
              <a for="request">credentials mode</a> to "`password`", and
              |request|'s <a for="request">attached credential</a> to
              |credentials|.

              Otherwise, set |request|'s <a for="request">credentials mode</a>
              to |credentials|.

  6.  Replace step 32 of the current {{Request}} constructor with the following:

      32. If |request|'s <a for="request">method</a> is `GET` or `HEAD`, then
          throw a `TypeError` if any of the following are true:

          *   <var ignore>init</var>'s `body` member is present and non-null
          *   <var ignore>inputBody</var> is non-null
          *   |request|'s <a for="request">attached credential</a> is non-null

  7.  The <a>HTTP-network-or-cache fetch</a> algorithm is updated with the
      following step after the existing step 2:

      3.  If |httpRequest|'s <a for="request">attached credential</a> is not
          null, run these substeps:

          1.  Assert: |httpRequest|'s <a for="request">body</a> is null.

          2.  Let |body| and |type| be the result of running
              [[#body-extraction]] on |httpRequest|.

          3.  If |type| is the empty string, return a <a>network error</a>.

          4.  Let |httpRequest|'s <a for="request">body</a> be |body|,
              <var ignore>Content-Type</var> be |type|, and <a for="request">redirect
              mode</a> be "`manual`".

  ISSUE(whatwg/fetch#237): These patches are combined into an outstanding
  pull request against Fetch.

  <h3 id="body-extraction" algorithm>
    Extract a |body| and |Content-Type| for |request|'s attached credential
  </h3>

  Given a {{Request}} (|request|), this algorithm returns a {{Body}} (|body|) and
  a string (|Content-Type|):

  1.  Let |credential| be |request|'s <a>attached credential</a>.

  2.  Let |body| be a new <a for="request">body</a>, and |Content-Type| be the empty string.

  3.  If |credential| is a {{PasswordCredential}}, run these substeps.

      1.  If |request|'s <a for="request">url</a>'s scheme is not the same as
          |request|'s <a for="request">client</a>'s {{URL/origin}}'s scheme,
          or |request|'s <a for="request">url</a>'s host's <a>registerable
          domain</a> is not the same as |request|'s
          <a for="request">client</a>'s {{URL/origin}}'s host's <a>registerable
          domain</a>, then skip the remaining substeps.

      2.  Let |data| be a copy of |credential|'s
          {{PasswordCredential/additionalData}} attribute if it is not
          `undefined`, and a new {{FormData}} object otherwise.

      3.  Let |list| be an empty list.

      4.  If |data| is a {{FormData}} object, then:

          1.  Set |list| to a copy of |data|'s <a for="FormData">entries</a>.

          2.  Remove all <a>entry</a> objects from |list| whose
              <a for="entry">name</a> is either |credential|'s
              {{PasswordCredential/idName}} or |credential|'s
              {{PasswordCredential/passwordName}}.

          3.  Let |entry| be a new <a>entry</a> whose <a for="entry">name</a>
              is |credential|'s {{PasswordCredential/idName}} and whose
              <a for="entry">value</a> is |credential|'s {{Credential/id}}.

          4.  Append |entry| to |list|.

          5.  Let |entry| be a new <a>entry</a> whose <a for="entry">name</a>
              is |credential|'s {{PasswordCredential/passwordName}} and whose
              <a for="entry">value</a> is |credential|'s {{[[password]]}}.

          6.  Append |entry| to |list|.

          7.  Push the result of running the <a>`multipart/form-data` encoding
              algorithm</a>, with |list| as the form data set and with "`utf-8`" as
              the explicit character encoding, to |body|'s
              <a for="body">stream</a>.

          8.  Set |Content-Type| to `multipart/form-data;boundary=`, followed by the
              <a>`multipart/form-data` boundary string</a> generated by the
              multipart/form-data encoding algorithm.

          Otherwise |data| is a {{URLSearchParams}} object, so:

          1.  Set |list| to a copy of |data|'s
              <a for="URLSearchParams">list</a>.

          2.  Remove all name-value pairs from |list| whose name is either
              |credential|'s {{PasswordCredential/idName}} or |credential|'s
              {{PasswordCredential/passwordName}}.

          3.  Append a new name-value pair to |list| whose name is 
              |credential|'s {{PasswordCredential/idName}} and whose value is
              |credential|'s {{Credential/id}}.

          4.  Append a new name-value pair to |list| whose name is 
              |credential|'s {{PasswordCredential/passwordName}} and whose value
              is |credential|'s {{[[password]]}}.

          5.  Push the result of running the <a>urlencoded byte serializer</a> with |list|, to
              |body|'s <a for="body">stream</a>.

          6.  Set |Content-Type| to
              `application/x-www-form-urlencoded;charset=UTF-8`.

  4.  Return |body| and |Content-Type|. 
</section>

<section>
  # Algorithms # {#algorithms}

  ## `SiteBoundCredential` Algorithms ## {#siteboundcredential-algorithms}

  <h4 algorithm id="request-credential">
    Request a `SiteBoundCredential`
  </h4>

  {{SiteBoundCredential}}'s {{SiteBoundCredential/[[Retrieve]](options, mediation)}} internal
  method is called with a {{CredentialRequestOptions}} object (|options|), and either
  "`With User Mediation`" or "`Without User Mediation`" (|mediation|). It returns a
  {{SiteBoundCredential}} if one can be retrieved from the [=credential store=], or `null`
  otherwise:

  <ol class="algorithm">
    1.  Let |origin| be the [=environment settings object/origin=] of the
        [=current settings object=].

    2.  <a abstract-op>Retrieve an origin's `requires user mediation` flag</a> from the
        [=credential store=] for |origin|, and set |require mediation| to its value.

    3.  If |require mediation| is `true` and |mediation| is "`Without User Mediation`", return
        `null`.

        Note: If a user agent implements a "private browsing" mode, we recommend that this algorithm
        always return `null` when "private browsing mode" is activated and |mediation| is
        "`Without User Mediation`".

    4.  <a abstract-op>Retrieve a list of credentials</a> from the [=credential store=] which
        represent {{SiteBoundCredential}} objects whose {{SiteBoundCredential/[[origin]]}} is the
        <a>same origin</a> as |origin|. Let |list| be the result.

    5.  If |options| does not have a {{CredentialRequestOptions/password}} member whose value is
        `true`, remove all {{PasswordCredential}} objects from |list|.

    6.  If |options| does not have a {{CredentialRequestOptions/federated}} member, remove all
        {{FederatedCredential}} objects from |list|.

    7.  If |options| has a {{CredentialRequestOptions/federated}} member (|federated options|),
        then:

        1.  For each |credential| in |list|, remove |credential| from |list| _unless_ one or more
            of the following statements is true:

            *   |credential|'s {{FederatedCredential/provider}} is <a for="list">contained</a> in
                |federated options| {{FederatedCredentialRequestOptions/providers}} member's value.

            *   |credential|'s {{FederatedCredential/protocol}} is <a for="list">contained</a> in
                |federated options| {{FederatedCredentialRequestOptions/protocols}} member's value.

        Otherwise, remove all {{FederatedCredential}} objects from |list|.

    8.  If |mediation| is "`Without User Mediation`":

        1.  Assert: |require mediation| is `false`.

        2.  If |list|'s <a for="list">size</a> is 1, then return |list|[0].

        3.  Return `null`.

    9.  Present the user with a [=credential chooser=], using |list| as a data source.

        Note: This behavior is vendor-specific and unspecified outside the guidelines enumerated
        in the dicussion of [=credential choosers=] in [[CREDENTIAL-MANAGEMENT-1]].

    10. Return the {{SiteBoundCredential}} the user chose, or `null` if the user
        declined to share a credential.
  </ol>
  
  <h4 algorithm id="store-credential">
    Store a `SiteBoundCredential`
  </h4>
 
  Given a {{SiteBoundCredential}} (|credential|), this algorithm persists it to the
  [=credential store=], and then returns.

  <ol class="algorithm">
    1.  Assert: |credential|'s {{SiteBoundCredential/[[origin]]}} slot is the [=same origin=]
        as the [=current settings object=]'s [=environment settings object/origin=].

    2.  Assert: |credential|'s {{SiteBoundCredential/iconURL}} is an <a><i lang="la">a priori</i>
        authenticated URL</a>, or the empty string.

    3.  If |credential| is a {{PasswordCredential}}:

        1.  If the user agent's [=credential store=] contains a {{PasswordCredential}} (|stored|)
            whose {{Credential/id}} attribute is |credential|'s {{Credential/id}} and whose
            {{[[origin]]}} slot is the [=same origin=] as |credential|'s
            {{SiteBoundCredential/[[origin]]}}, then:

            1.  If the user grants permission to update credentials (as discussed when defining
                [=user mediation=] in [[CREDENTIAL-MANAGEMENT-1]]), then:

                1.  Set |stored|'s {{[[password]]}} slot's value to the value of |credential|'s
                    {{[[password]]}} slot.

                2.  Set |stored|'s {{SiteBoundCredential/name}} to |credential|'s
                    {{SiteBoundCredential/name}}.

                3.  Set |stored|'s {{SiteBoundCredential/iconURL}} to |credential|'s
                    {{SiteBoundCredential/iconURL}}.

                Otherwise, if the user grants permission to store credentials (as discussed when
                defining [=user mediation=] in [[CREDENTIAL-MANAGEMENT-1]]), then: 

                1.  Store a {{PasswordCredential}} in the [=credential store=] with the following
                    properties:
                    
                    :   {{Credential/id}}
                    ::  |credential|'s {{Credential/id}}
                    :   {{SiteBoundCredential/name}},
                    ::  |credential|'s {{SiteBoundCredential/name}}
                    :   {{SiteBoundCredential/iconURL}}
                    ::  |credential|'s {{SiteBoundCredential/iconURL}}
                    :   {{[[origin]]}}
                    ::  |credential|'s {{[[origin]]}}
                    :   {{[[password]]}}
                    ::  |credential|'s {{[[password]]}}

                    Note: Ancillary properties like {{PasswordCredential/idName}},
                    {{PasswordCredential/passwordName}}, and {{PasswordCredential/additionalData}}
                    are _not_ stored in the [=credential store=]. They are used for a single
                    authentication event, and are expected to be populated at request time.

    4.  Otherwise, |credential| is a {{FederatedCredential}}:

        1.  If the user agent's [=credential store=] contains a {{FederatedCredential}} whose
            {{Credential/id}} attribute is |credential|'s {{Credential/id}} and whose {{[[origin]]}}
            slot is the [=same origin=] as |credential|'s {{SiteBoundCredential/[[origin]]}}, and
            whose {{FederatedCredential/provider}} is |credential|'s
            {{FederatedCredential/provider}}, then return.

        2.  Store a {{FederatedCredential}} in the [=credential store=] with the following
            properties:

            :   {{Credential/id}}
            ::  |credential|'s {{Credential/id}}
            :   {{SiteBoundCredential/name}},
            ::  |credential|'s {{SiteBoundCredential/name}}
            :   {{SiteBoundCredential/iconURL}}
            ::  |credential|'s {{SiteBoundCredential/iconURL}}
            :   {{[[origin]]}}
            ::  |credential|'s {{[[origin]]}}
            :   {{FederatedCredential/provider}}
            ::  |credential|'s {{FederatedCredential/provider}}
            :   {{FederatedCredential/protocol}}
            ::  |credential|'s {{FederatedCredential/protocol}}
  </ol>

  ## `PasswordCredential` Algorithms ## {#passwordcredential-algorithms}

  <h4 algorithm id="construct-passwordcredential-form">
    The `PasswordCredental(HTMLFormElement)` Constructor
  </h4>

  The {{PasswordCredential(form)}} constructor, when invoked with an {{HTMLFormElement}} (|form|),
  must run these steps.
  
  Note: [[#examples-post-signin]] and [[#examples-change-password]] provide examples of the intended
  usage.

  <ol class="algorithm">
    1.  Let |data| be a new {{PasswordCredentialData}} dictionary.

    2.  Let |formData| be the result of executing the {{FormData}} constructor
        on |form|.

    3.  Let |elements| be a list of all the [=submittable elements=] whose [=form owner=] is |form|, in [=tree order=].

    4.  Let |idName| and |passwordName| be empty strings.

    5.  Let |newPasswordObserved| be `false`.

    6.  For each |field| in |elements|, run the following steps:

        1.  If |field| does not have an <{input/autocomplete}> attribute, then skip to the next
            |field|.

        2.  Let |name| be the value of |field|'s <{input/name}> attribute.

        3.  If |formData|'s {{FormData/has()}} method returns `false` when executed on |name|, then
            skip to the next |field|.

        4.  If |field|'s <{input/autocomplete}> attribute's value contains one or more [=autofill
            detail tokens=] (|tokens|), then:
            
            1.  For each |token| in |tokens|:
            
                1.  If |token| is an <a>ASCII case-insensitive</a> match for one
                    of the following strings, run the associated steps:

                    :   "<a attr-value>`new-password`</a>"
                    ::  Set |data|'s {{PasswordCredentialData/password}} member's
                        value to the result of executing |formData|'s
                        {{FormData/get()}} method on |name|, |passwordName| to
                        |name|, and |newPasswordObserved| to `true`.

                    :   "<a attr-value>`current-password`</a>"
                    ::  If |newPasswordObserved| is `false`,
                        set |data|'s {{PasswordCredentialData/password}} member's
                        value to the result of executing |formData|'s
                        {{FormData/get()}} method on |name|, and |passwordName| to
                        |name|.

                        Note: By checking that |newPasswordObserved| is `false`,
                        `new-password` fields take precedence over
                        `current-password` fields.

                    :   "<a attr-value>`photo`</a>"
                    ::  Set |data|'s {{SiteBoundCredentialData/iconURL}} member's
                        value to the result of executing |formData|'s
                        {{FormData/get()}} method on |name|.

                    :   "<a attr-value>`name`</a>"
                    :   "<a attr-value>`nickname`</a>"
                    ::  Set |data|'s {{SiteBoundCredentialData/name}} member's
                        value to the result of executing |formData|'s
                        {{FormData/get()}} method on |name|.

                    :   "<a attr-value>`username`</a>"
                    ::  Set |data|'s {{CredentialData/id}} member's value to the
                        result of executing |formData|'s {{FormData/get()}} method
                        on |name|, and |idName| to |name|.

    7.  Let |c| be the result of executing the {{PasswordCredential(data)}} constructor on |data|.
        Rethrow any exception generated.

    8.  Set |c|'s {{PasswordCredential/idName}} attribute to |idName|.

    9.  Set |c|'s {{PasswordCredential/passwordName}} attribute to |passwordName|.

    10. If |form|'s <{form/enctype}> is "`multipart/form-data`", then:
       
        1.  Set |c|'s {{PasswordCredential/additionalData}} attribute to |formData|.

        Otherwise:

        1.  Let |params| be a new {{URLSearchParams}} object.

        2.  For each |entry| in |formData|'s <a for="FormData">entries</a>:

            1.  If |entry|'s <a for="entry">type</a> is "file", <a for="iteration">continue</a>.

            2.  Execute |params| {{URLSearchParams/append()}} method on |entry|'s [=entry/name=] and
                [=entry/value=].

        3.  Set |c|'s {{PasswordCredential/additionalData}} attribute to |params|.

    11. Return |c|.
  </ol>

  <h4 algorithm id="construct-passwordcredential-data">
    The `PasswordCredental(PasswordCredentialData)` Constructor
  </h4>

  The {{PasswordCredential(data)}} constructor, when invoked with a {{PasswordCredentialData}}
  (|data|), must run the following steps:

  <ol class="algorithm">
    1.  Let |c| be a new {{PasswordCredential}} object.
    
    2.  If any of the following are the empty string, <a>throw</a> a `TypeError` exception:

        *   |data|'s {{CredentialData/id}} member's value
        *   |data|'s {{PasswordCredentialData/password}} member's value

    3.  Set |c|'s properties as follows:
    
        :   {{PasswordCredential/[[password]]}} slot
        ::  |data|'s {{PasswordCredentialData/password}} member's value
        :   {{Credential/id}}
        ::  |data|'s {{CredentialData/id}} member's value
        :   {{PasswordCredential/idName}}
        ::  "`username`"
        :   {{SiteBoundCredential/iconURL}}
        ::  |data|'s {{SiteBoundCredentialData/iconURL}} member's value
        :   {{SiteBoundCredential/name}}
        ::  |data|'s {{SiteBoundCredentialData/name}} member's value
        :   {{PasswordCredential/passwordName}}
        ::  "`password`"
        :   {{SiteBoundCredential/[[origin]]}}
        ::  The [=environment settings object/origin=] of the [=current settings object=].

    4.  Return |c|.
  </ol>

  <h4 algorithm id="passwordcredential-matching">
    `CredentialRequestOptions` Matching for `PasswordCredential`
  </h4>

  Given a {{CredentialRequestOptions}} (|options|), the following algorithm returns "`Matches`" if
  the {{PasswordCredential}} should be available as a response to a {{CredentialsContainer/get()}}
  request, and "`Does Not Match`" otherwise.

  1.  If |options| has a {{CredentialRequestOptions/password}} member whose value is `true`, then
      return "`Matches`".

  2.  Return "`Does Not Match`".

  ## `FederatedCredential` Algorithms ## {#federatedcredential-algorithms}

  <h4 algorithm id="construct-federatedcredential-data">
    The `PasswordCredental(FederatedCredentialData)` Constructor
  </h4>

  The {{FederatedCredential(data)}} constructor, when invoked with a {{FederatedCredentialData}}
  (|data|), must run the following steps:

  <ol class="algorithm">
    1.  Let |c| be a new {{FederatedCredential}} object.
    
    2.  If any of the following are the empty string, <a>throw</a> a `TypeError` exception:

        *   |data|'s {{CredentialData/id}} member's value
        *   |data|'s {{FederatedCredentialData/provider}} member's value

    3.  Set |c|'s properties as follows:
    
        :   {{Credential/id}}
        ::  |data|'s {{CredentialData/id}} member's value
        :   {{FederatedCredential/provider}}
        ::  |data|'s {{FederatedCredentialData/provider}} member's value
        :   {{SiteBoundCredential/iconURL}}
        ::  |data|'s {{SiteBoundCredentialData/iconURL}} member's value
        :   {{SiteBoundCredential/name}}
        ::  |data|'s {{SiteBoundCredentialData/name}} member's value
        :   {{SiteBoundCredential/[[origin]]}}
        ::  The [=environment settings object/origin=] of the [=current settings object=].

    4.  Return |c|.
  </ol>
</section>

<section>
  # Security and Privacy Considerations # {#security-and-privacy}

  ## Cross-origin Credential Leakage ## {#security-cross-origin-leakage}

  Credentials are sensitive information, and user agents need to exercise caution in determining
  when they can be safely shared with a website. The safest option is to restrict credential
  sharing to the exact origin on which they were saved. That is likely too restrictive for the
  web, however: consider sites which divide functionality into subdomains like `example.com` vs
  `admin.example.com`.

  As a compromise between annoying users, and securing their credentials, user agents:

  1.  MUST NOT share credentials between origins whose scheme components represent a downgrade in
      security. That is, it may make sense to allow credentials saved on `http://example.com/` to
      be made available to `https://example.com/` (in order to encourage developers to migrate to
      secure transport), but the inverse would be dangerous.

  2.  MAY use the Public Suffix List [[!PSL]] to determine the effective scope of a credential by
      comparing the [=registerable domain=] of the credential's {{[[origin]]}} with the origin in
      which {{CredentialsContainer/get()}} is called. That is: credentials saved on
      `https://admin.example.com/` and `https://example.com/` MAY be offered to users when
      {{CredentialsContainer/get()}} is called from `https://www.example.com/`, and vice versa.

  3.  MUST NOT offer credentials to an origin in response to {{CredentialsContainer/get()}} without
      [=user mediation=] if the credential's origin is not an exact match for the calling origin.
      That is, {{Credential}} objects for `https://example.com` would not be returned directly to
      `https://www.example.com`, but could be offered to the user via the chooser.

  {{PasswordCredential}}s further mitigate the risk of data leakage by never exposing the
  {{[[password]]}} slot directly to a page's JavaScript, but only allowing its submission to a
  same-origin server-side endpoint via {{fetch()}}.
</section>

<section>
  # Future Work # {#future-work}

  <em>This section is non-normative.</em>

  The API defined here does the bare minimum to expose user agent's credential managers to the web,
  and allows the web to help those credential managers understand when federated identity providers
  are in use. The next logical step will be along the lines sketched in documents like [[WEB-LOGIN]]
  (and, to some extent, Mozilla's BrowserID [[BROWSERID]]).

  The user agent is in the unique position of being able to effectively mediate the relationship
  between users, identity providers, and websites. If the user agent can remove some of the risk and
  confusion associated with the typical authentication flows, users will be in a significantly
  better position than today.

  A natural way to expose this information might be to extend the {{FederatedCredential}} interface
  with properties like authentication tokens, and possibly to add some form of manifest format with
  properties that declare the authentication type which the provider supports.

  The API described here is designed to be extensible enough to support use cases that require user
  interaction, perhaps with websites other than the one which requested credentials. We hope that
  the {{Promise}}-based system we've settled on is extensible enough to support these kinds of
  asynchronous flows which could require some level of interaction between multiple browsing
  contexts (e.g. mediated activity on `idp.com` might resolve a {{Promise}} handed back to `rp.com`)
  in the future without redesigning the API from the ground up.

  Baby steps.
</section>
